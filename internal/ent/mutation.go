// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"lms-go/internal/ent/content"
	"lms-go/internal/ent/course"
	"lms-go/internal/ent/enrollment"
	"lms-go/internal/ent/group"
	"lms-go/internal/ent/module"
	"lms-go/internal/ent/moduleprogress"
	"lms-go/internal/ent/organization"
	"lms-go/internal/ent/predicate"
	"lms-go/internal/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeContent        = "Content"
	TypeCourse         = "Course"
	TypeEnrollment     = "Enrollment"
	TypeGroup          = "Group"
	TypeModule         = "Module"
	TypeModuleProgress = "ModuleProgress"
	TypeOrganization   = "Organization"
	TypeUser           = "User"
)

// ContentMutation represents an operation that mutates the Content nodes in the graph.
type ContentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	mime_type           *string
	size_bytes          *int64
	addsize_bytes       *int64
	storage_key         *string
	status              *string
	metadata            *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	modules             map[uuid.UUID]struct{}
	removedmodules      map[uuid.UUID]struct{}
	clearedmodules      bool
	done                bool
	oldValue            func(context.Context) (*Content, error)
	predicates          []predicate.Content
}

var _ ent.Mutation = (*ContentMutation)(nil)

// contentOption allows management of the mutation configuration using functional options.
type contentOption func(*ContentMutation)

// newContentMutation creates new mutation for the Content entity.
func newContentMutation(c config, op Op, opts ...contentOption) *ContentMutation {
	m := &ContentMutation{
		config:        c,
		op:            op,
		typ:           TypeContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentID sets the ID field of the mutation.
func withContentID(id uuid.UUID) contentOption {
	return func(m *ContentMutation) {
		var (
			err   error
			once  sync.Once
			value *Content
		)
		m.oldValue = func(ctx context.Context) (*Content, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Content.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContent sets the old Content of the mutation.
func withContent(node *Content) contentOption {
	return func(m *ContentMutation) {
		m.oldValue = func(context.Context) (*Content, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Content entities.
func (m *ContentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Content.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *ContentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ContentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ContentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetName sets the "name" field.
func (m *ContentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContentMutation) ResetName() {
	m.name = nil
}

// SetMimeType sets the "mime_type" field.
func (m *ContentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *ContentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *ContentMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *ContentMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *ContentMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *ContentMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *ContentMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *ContentMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[content.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *ContentMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[content.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *ContentMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, content.FieldSizeBytes)
}

// SetStorageKey sets the "storage_key" field.
func (m *ContentMutation) SetStorageKey(s string) {
	m.storage_key = &s
}

// StorageKey returns the value of the "storage_key" field in the mutation.
func (m *ContentMutation) StorageKey() (r string, exists bool) {
	v := m.storage_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageKey returns the old "storage_key" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldStorageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageKey: %w", err)
	}
	return oldValue.StorageKey, nil
}

// ResetStorageKey resets all changes to the "storage_key" field.
func (m *ContentMutation) ResetStorageKey() {
	m.storage_key = nil
}

// SetStatus sets the "status" field.
func (m *ContentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ContentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ContentMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *ContentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ContentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ContentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[content.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ContentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[content.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ContentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, content.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ContentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[content.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ContentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ContentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ContentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddModuleIDs adds the "modules" edge to the Module entity by ids.
func (m *ContentMutation) AddModuleIDs(ids ...uuid.UUID) {
	if m.modules == nil {
		m.modules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modules[ids[i]] = struct{}{}
	}
}

// ClearModules clears the "modules" edge to the Module entity.
func (m *ContentMutation) ClearModules() {
	m.clearedmodules = true
}

// ModulesCleared reports if the "modules" edge to the Module entity was cleared.
func (m *ContentMutation) ModulesCleared() bool {
	return m.clearedmodules
}

// RemoveModuleIDs removes the "modules" edge to the Module entity by IDs.
func (m *ContentMutation) RemoveModuleIDs(ids ...uuid.UUID) {
	if m.removedmodules == nil {
		m.removedmodules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modules, ids[i])
		m.removedmodules[ids[i]] = struct{}{}
	}
}

// RemovedModules returns the removed IDs of the "modules" edge to the Module entity.
func (m *ContentMutation) RemovedModulesIDs() (ids []uuid.UUID) {
	for id := range m.removedmodules {
		ids = append(ids, id)
	}
	return
}

// ModulesIDs returns the "modules" edge IDs in the mutation.
func (m *ContentMutation) ModulesIDs() (ids []uuid.UUID) {
	for id := range m.modules {
		ids = append(ids, id)
	}
	return
}

// ResetModules resets all changes to the "modules" edge.
func (m *ContentMutation) ResetModules() {
	m.modules = nil
	m.clearedmodules = false
	m.removedmodules = nil
}

// Where appends a list predicates to the ContentMutation builder.
func (m *ContentMutation) Where(ps ...predicate.Content) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Content, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Content).
func (m *ContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.organization != nil {
		fields = append(fields, content.FieldOrganizationID)
	}
	if m.name != nil {
		fields = append(fields, content.FieldName)
	}
	if m.mime_type != nil {
		fields = append(fields, content.FieldMimeType)
	}
	if m.size_bytes != nil {
		fields = append(fields, content.FieldSizeBytes)
	}
	if m.storage_key != nil {
		fields = append(fields, content.FieldStorageKey)
	}
	if m.status != nil {
		fields = append(fields, content.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, content.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, content.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, content.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case content.FieldOrganizationID:
		return m.OrganizationID()
	case content.FieldName:
		return m.Name()
	case content.FieldMimeType:
		return m.MimeType()
	case content.FieldSizeBytes:
		return m.SizeBytes()
	case content.FieldStorageKey:
		return m.StorageKey()
	case content.FieldStatus:
		return m.Status()
	case content.FieldMetadata:
		return m.Metadata()
	case content.FieldCreatedAt:
		return m.CreatedAt()
	case content.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case content.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case content.FieldName:
		return m.OldName(ctx)
	case content.FieldMimeType:
		return m.OldMimeType(ctx)
	case content.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case content.FieldStorageKey:
		return m.OldStorageKey(ctx)
	case content.FieldStatus:
		return m.OldStatus(ctx)
	case content.FieldMetadata:
		return m.OldMetadata(ctx)
	case content.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case content.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Content field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case content.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case content.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case content.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case content.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case content.FieldStorageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageKey(v)
		return nil
	case content.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case content.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case content.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case content.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Content field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, content.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case content.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case content.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Content numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(content.FieldSizeBytes) {
		fields = append(fields, content.FieldSizeBytes)
	}
	if m.FieldCleared(content.FieldMetadata) {
		fields = append(fields, content.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentMutation) ClearField(name string) error {
	switch name {
	case content.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case content.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Content nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentMutation) ResetField(name string) error {
	switch name {
	case content.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case content.FieldName:
		m.ResetName()
		return nil
	case content.FieldMimeType:
		m.ResetMimeType()
		return nil
	case content.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case content.FieldStorageKey:
		m.ResetStorageKey()
		return nil
	case content.FieldStatus:
		m.ResetStatus()
		return nil
	case content.FieldMetadata:
		m.ResetMetadata()
		return nil
	case content.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case content.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Content field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, content.EdgeOrganization)
	}
	if m.modules != nil {
		edges = append(edges, content.EdgeModules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case content.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case content.EdgeModules:
		ids := make([]ent.Value, 0, len(m.modules))
		for id := range m.modules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmodules != nil {
		edges = append(edges, content.EdgeModules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case content.EdgeModules:
		ids := make([]ent.Value, 0, len(m.removedmodules))
		for id := range m.removedmodules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, content.EdgeOrganization)
	}
	if m.clearedmodules {
		edges = append(edges, content.EdgeModules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentMutation) EdgeCleared(name string) bool {
	switch name {
	case content.EdgeOrganization:
		return m.clearedorganization
	case content.EdgeModules:
		return m.clearedmodules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentMutation) ClearEdge(name string) error {
	switch name {
	case content.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Content unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentMutation) ResetEdge(name string) error {
	switch name {
	case content.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case content.EdgeModules:
		m.ResetModules()
		return nil
	}
	return fmt.Errorf("unknown Content edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	slug                *string
	description         *string
	status              *string
	version             *int
	addversion          *int
	metadata            *map[string]interface{}
	published_at        *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	modules             map[uuid.UUID]struct{}
	removedmodules      map[uuid.UUID]struct{}
	clearedmodules      bool
	enrollments         map[uuid.UUID]struct{}
	removedenrollments  map[uuid.UUID]struct{}
	clearedenrollments  bool
	groups              map[uuid.UUID]struct{}
	removedgroups       map[uuid.UUID]struct{}
	clearedgroups       bool
	done                bool
	oldValue            func(context.Context) (*Course, error)
	predicates          []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id uuid.UUID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *CourseMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CourseMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CourseMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *CourseMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CourseMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CourseMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CourseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[course.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CourseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[course.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, course.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *CourseMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseMutation) ResetStatus() {
	m.status = nil
}

// SetVersion sets the "version" field.
func (m *CourseMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CourseMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CourseMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CourseMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CourseMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetMetadata sets the "metadata" field.
func (m *CourseMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CourseMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CourseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[course.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CourseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[course.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CourseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, course.FieldMetadata)
}

// SetPublishedAt sets the "published_at" field.
func (m *CourseMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *CourseMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPublishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *CourseMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[course.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *CourseMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[course.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *CourseMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, course.FieldPublishedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CourseMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[course.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CourseMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CourseMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddModuleIDs adds the "modules" edge to the Module entity by ids.
func (m *CourseMutation) AddModuleIDs(ids ...uuid.UUID) {
	if m.modules == nil {
		m.modules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modules[ids[i]] = struct{}{}
	}
}

// ClearModules clears the "modules" edge to the Module entity.
func (m *CourseMutation) ClearModules() {
	m.clearedmodules = true
}

// ModulesCleared reports if the "modules" edge to the Module entity was cleared.
func (m *CourseMutation) ModulesCleared() bool {
	return m.clearedmodules
}

// RemoveModuleIDs removes the "modules" edge to the Module entity by IDs.
func (m *CourseMutation) RemoveModuleIDs(ids ...uuid.UUID) {
	if m.removedmodules == nil {
		m.removedmodules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modules, ids[i])
		m.removedmodules[ids[i]] = struct{}{}
	}
}

// RemovedModules returns the removed IDs of the "modules" edge to the Module entity.
func (m *CourseMutation) RemovedModulesIDs() (ids []uuid.UUID) {
	for id := range m.removedmodules {
		ids = append(ids, id)
	}
	return
}

// ModulesIDs returns the "modules" edge IDs in the mutation.
func (m *CourseMutation) ModulesIDs() (ids []uuid.UUID) {
	for id := range m.modules {
		ids = append(ids, id)
	}
	return
}

// ResetModules resets all changes to the "modules" edge.
func (m *CourseMutation) ResetModules() {
	m.modules = nil
	m.clearedmodules = false
	m.removedmodules = nil
}

// AddEnrollmentIDs adds the "enrollments" edge to the Enrollment entity by ids.
func (m *CourseMutation) AddEnrollmentIDs(ids ...uuid.UUID) {
	if m.enrollments == nil {
		m.enrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the Enrollment entity.
func (m *CourseMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the Enrollment entity was cleared.
func (m *CourseMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the Enrollment entity by IDs.
func (m *CourseMutation) RemoveEnrollmentIDs(ids ...uuid.UUID) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the Enrollment entity.
func (m *CourseMutation) RemovedEnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *CourseMutation) EnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *CourseMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *CourseMutation) AddGroupIDs(ids ...uuid.UUID) {
	if m.groups == nil {
		m.groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *CourseMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *CourseMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *CourseMutation) RemoveGroupIDs(ids ...uuid.UUID) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *CourseMutation) RemovedGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *CourseMutation) GroupsIDs() (ids []uuid.UUID) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *CourseMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.organization != nil {
		fields = append(fields, course.FieldOrganizationID)
	}
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, course.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, course.FieldStatus)
	}
	if m.version != nil {
		fields = append(fields, course.FieldVersion)
	}
	if m.metadata != nil {
		fields = append(fields, course.FieldMetadata)
	}
	if m.published_at != nil {
		fields = append(fields, course.FieldPublishedAt)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldOrganizationID:
		return m.OrganizationID()
	case course.FieldTitle:
		return m.Title()
	case course.FieldSlug:
		return m.Slug()
	case course.FieldDescription:
		return m.Description()
	case course.FieldStatus:
		return m.Status()
	case course.FieldVersion:
		return m.Version()
	case course.FieldMetadata:
		return m.Metadata()
	case course.FieldPublishedAt:
		return m.PublishedAt()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldSlug:
		return m.OldSlug(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldStatus:
		return m.OldStatus(ctx)
	case course.FieldVersion:
		return m.OldVersion(ctx)
	case course.FieldMetadata:
		return m.OldMetadata(ctx)
	case course.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case course.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case course.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case course.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, course.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldDescription) {
		fields = append(fields, course.FieldDescription)
	}
	if m.FieldCleared(course.FieldMetadata) {
		fields = append(fields, course.FieldMetadata)
	}
	if m.FieldCleared(course.FieldPublishedAt) {
		fields = append(fields, course.FieldPublishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldDescription:
		m.ClearDescription()
		return nil
	case course.FieldMetadata:
		m.ClearMetadata()
		return nil
	case course.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldSlug:
		m.ResetSlug()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldStatus:
		m.ResetStatus()
		return nil
	case course.FieldVersion:
		m.ResetVersion()
		return nil
	case course.FieldMetadata:
		m.ResetMetadata()
		return nil
	case course.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, course.EdgeOrganization)
	}
	if m.modules != nil {
		edges = append(edges, course.EdgeModules)
	}
	if m.enrollments != nil {
		edges = append(edges, course.EdgeEnrollments)
	}
	if m.groups != nil {
		edges = append(edges, course.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeModules:
		ids := make([]ent.Value, 0, len(m.modules))
		for id := range m.modules {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmodules != nil {
		edges = append(edges, course.EdgeModules)
	}
	if m.removedenrollments != nil {
		edges = append(edges, course.EdgeEnrollments)
	}
	if m.removedgroups != nil {
		edges = append(edges, course.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeModules:
		ids := make([]ent.Value, 0, len(m.removedmodules))
		for id := range m.removedmodules {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, course.EdgeOrganization)
	}
	if m.clearedmodules {
		edges = append(edges, course.EdgeModules)
	}
	if m.clearedenrollments {
		edges = append(edges, course.EdgeEnrollments)
	}
	if m.clearedgroups {
		edges = append(edges, course.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeOrganization:
		return m.clearedorganization
	case course.EdgeModules:
		return m.clearedmodules
	case course.EdgeEnrollments:
		return m.clearedenrollments
	case course.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case course.EdgeModules:
		m.ResetModules()
		return nil
	case course.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	case course.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// EnrollmentMutation represents an operation that mutates the Enrollment nodes in the graph.
type EnrollmentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	status                  *string
	progress                *float32
	addprogress             *float32
	started_at              *time.Time
	completed_at            *time.Time
	metadata                *map[string]interface{}
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	organization            *uuid.UUID
	clearedorganization     bool
	course                  *uuid.UUID
	clearedcourse           bool
	user                    *uuid.UUID
	cleareduser             bool
	group                   *uuid.UUID
	clearedgroup            bool
	progress_entries        map[uuid.UUID]struct{}
	removedprogress_entries map[uuid.UUID]struct{}
	clearedprogress_entries bool
	done                    bool
	oldValue                func(context.Context) (*Enrollment, error)
	predicates              []predicate.Enrollment
}

var _ ent.Mutation = (*EnrollmentMutation)(nil)

// enrollmentOption allows management of the mutation configuration using functional options.
type enrollmentOption func(*EnrollmentMutation)

// newEnrollmentMutation creates new mutation for the Enrollment entity.
func newEnrollmentMutation(c config, op Op, opts ...enrollmentOption) *EnrollmentMutation {
	m := &EnrollmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnrollment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnrollmentID sets the ID field of the mutation.
func withEnrollmentID(id uuid.UUID) enrollmentOption {
	return func(m *EnrollmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Enrollment
		)
		m.oldValue = func(ctx context.Context) (*Enrollment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Enrollment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnrollment sets the old Enrollment of the mutation.
func withEnrollment(node *Enrollment) enrollmentOption {
	return func(m *EnrollmentMutation) {
		m.oldValue = func(context.Context) (*Enrollment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnrollmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnrollmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Enrollment entities.
func (m *EnrollmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnrollmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnrollmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Enrollment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *EnrollmentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EnrollmentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EnrollmentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCourseID sets the "course_id" field.
func (m *EnrollmentMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *EnrollmentMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldCourseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *EnrollmentMutation) ResetCourseID() {
	m.course = nil
}

// SetUserID sets the "user_id" field.
func (m *EnrollmentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EnrollmentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EnrollmentMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *EnrollmentMutation) SetGroupID(u uuid.UUID) {
	m.group = &u
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *EnrollmentMutation) GroupID() (r uuid.UUID, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldGroupID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *EnrollmentMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[enrollment.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *EnrollmentMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[enrollment.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *EnrollmentMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, enrollment.FieldGroupID)
}

// SetStatus sets the "status" field.
func (m *EnrollmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EnrollmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EnrollmentMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *EnrollmentMutation) SetProgress(f float32) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *EnrollmentMutation) Progress() (r float32, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldProgress(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *EnrollmentMutation) AddProgress(f float32) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *EnrollmentMutation) AddedProgress() (r float32, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *EnrollmentMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetStartedAt sets the "started_at" field.
func (m *EnrollmentMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *EnrollmentMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *EnrollmentMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[enrollment.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *EnrollmentMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[enrollment.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *EnrollmentMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, enrollment.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *EnrollmentMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *EnrollmentMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *EnrollmentMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[enrollment.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *EnrollmentMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[enrollment.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *EnrollmentMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, enrollment.FieldCompletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *EnrollmentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EnrollmentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EnrollmentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[enrollment.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EnrollmentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[enrollment.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EnrollmentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, enrollment.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *EnrollmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnrollmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnrollmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnrollmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnrollmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Enrollment entity.
// If the Enrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnrollmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EnrollmentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[enrollment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EnrollmentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EnrollmentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EnrollmentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *EnrollmentMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[enrollment.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *EnrollmentMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *EnrollmentMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *EnrollmentMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *EnrollmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[enrollment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EnrollmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EnrollmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EnrollmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *EnrollmentMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[enrollment.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *EnrollmentMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *EnrollmentMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *EnrollmentMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddProgressEntryIDs adds the "progress_entries" edge to the ModuleProgress entity by ids.
func (m *EnrollmentMutation) AddProgressEntryIDs(ids ...uuid.UUID) {
	if m.progress_entries == nil {
		m.progress_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.progress_entries[ids[i]] = struct{}{}
	}
}

// ClearProgressEntries clears the "progress_entries" edge to the ModuleProgress entity.
func (m *EnrollmentMutation) ClearProgressEntries() {
	m.clearedprogress_entries = true
}

// ProgressEntriesCleared reports if the "progress_entries" edge to the ModuleProgress entity was cleared.
func (m *EnrollmentMutation) ProgressEntriesCleared() bool {
	return m.clearedprogress_entries
}

// RemoveProgressEntryIDs removes the "progress_entries" edge to the ModuleProgress entity by IDs.
func (m *EnrollmentMutation) RemoveProgressEntryIDs(ids ...uuid.UUID) {
	if m.removedprogress_entries == nil {
		m.removedprogress_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.progress_entries, ids[i])
		m.removedprogress_entries[ids[i]] = struct{}{}
	}
}

// RemovedProgressEntries returns the removed IDs of the "progress_entries" edge to the ModuleProgress entity.
func (m *EnrollmentMutation) RemovedProgressEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedprogress_entries {
		ids = append(ids, id)
	}
	return
}

// ProgressEntriesIDs returns the "progress_entries" edge IDs in the mutation.
func (m *EnrollmentMutation) ProgressEntriesIDs() (ids []uuid.UUID) {
	for id := range m.progress_entries {
		ids = append(ids, id)
	}
	return
}

// ResetProgressEntries resets all changes to the "progress_entries" edge.
func (m *EnrollmentMutation) ResetProgressEntries() {
	m.progress_entries = nil
	m.clearedprogress_entries = false
	m.removedprogress_entries = nil
}

// Where appends a list predicates to the EnrollmentMutation builder.
func (m *EnrollmentMutation) Where(ps ...predicate.Enrollment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnrollmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnrollmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Enrollment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnrollmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnrollmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Enrollment).
func (m *EnrollmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnrollmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.organization != nil {
		fields = append(fields, enrollment.FieldOrganizationID)
	}
	if m.course != nil {
		fields = append(fields, enrollment.FieldCourseID)
	}
	if m.user != nil {
		fields = append(fields, enrollment.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, enrollment.FieldGroupID)
	}
	if m.status != nil {
		fields = append(fields, enrollment.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, enrollment.FieldProgress)
	}
	if m.started_at != nil {
		fields = append(fields, enrollment.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, enrollment.FieldCompletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, enrollment.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, enrollment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enrollment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnrollmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enrollment.FieldOrganizationID:
		return m.OrganizationID()
	case enrollment.FieldCourseID:
		return m.CourseID()
	case enrollment.FieldUserID:
		return m.UserID()
	case enrollment.FieldGroupID:
		return m.GroupID()
	case enrollment.FieldStatus:
		return m.Status()
	case enrollment.FieldProgress:
		return m.Progress()
	case enrollment.FieldStartedAt:
		return m.StartedAt()
	case enrollment.FieldCompletedAt:
		return m.CompletedAt()
	case enrollment.FieldMetadata:
		return m.Metadata()
	case enrollment.FieldCreatedAt:
		return m.CreatedAt()
	case enrollment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnrollmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enrollment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case enrollment.FieldCourseID:
		return m.OldCourseID(ctx)
	case enrollment.FieldUserID:
		return m.OldUserID(ctx)
	case enrollment.FieldGroupID:
		return m.OldGroupID(ctx)
	case enrollment.FieldStatus:
		return m.OldStatus(ctx)
	case enrollment.FieldProgress:
		return m.OldProgress(ctx)
	case enrollment.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case enrollment.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case enrollment.FieldMetadata:
		return m.OldMetadata(ctx)
	case enrollment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enrollment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Enrollment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrollmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enrollment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case enrollment.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case enrollment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case enrollment.FieldGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case enrollment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case enrollment.FieldProgress:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case enrollment.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case enrollment.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case enrollment.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case enrollment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enrollment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Enrollment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnrollmentMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, enrollment.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnrollmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enrollment.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrollmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enrollment.FieldProgress:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Enrollment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnrollmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enrollment.FieldGroupID) {
		fields = append(fields, enrollment.FieldGroupID)
	}
	if m.FieldCleared(enrollment.FieldStartedAt) {
		fields = append(fields, enrollment.FieldStartedAt)
	}
	if m.FieldCleared(enrollment.FieldCompletedAt) {
		fields = append(fields, enrollment.FieldCompletedAt)
	}
	if m.FieldCleared(enrollment.FieldMetadata) {
		fields = append(fields, enrollment.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnrollmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnrollmentMutation) ClearField(name string) error {
	switch name {
	case enrollment.FieldGroupID:
		m.ClearGroupID()
		return nil
	case enrollment.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case enrollment.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case enrollment.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Enrollment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnrollmentMutation) ResetField(name string) error {
	switch name {
	case enrollment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case enrollment.FieldCourseID:
		m.ResetCourseID()
		return nil
	case enrollment.FieldUserID:
		m.ResetUserID()
		return nil
	case enrollment.FieldGroupID:
		m.ResetGroupID()
		return nil
	case enrollment.FieldStatus:
		m.ResetStatus()
		return nil
	case enrollment.FieldProgress:
		m.ResetProgress()
		return nil
	case enrollment.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case enrollment.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case enrollment.FieldMetadata:
		m.ResetMetadata()
		return nil
	case enrollment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enrollment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Enrollment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnrollmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.organization != nil {
		edges = append(edges, enrollment.EdgeOrganization)
	}
	if m.course != nil {
		edges = append(edges, enrollment.EdgeCourse)
	}
	if m.user != nil {
		edges = append(edges, enrollment.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, enrollment.EdgeGroup)
	}
	if m.progress_entries != nil {
		edges = append(edges, enrollment.EdgeProgressEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnrollmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enrollment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case enrollment.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case enrollment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case enrollment.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case enrollment.EdgeProgressEntries:
		ids := make([]ent.Value, 0, len(m.progress_entries))
		for id := range m.progress_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnrollmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprogress_entries != nil {
		edges = append(edges, enrollment.EdgeProgressEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnrollmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enrollment.EdgeProgressEntries:
		ids := make([]ent.Value, 0, len(m.removedprogress_entries))
		for id := range m.removedprogress_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnrollmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorganization {
		edges = append(edges, enrollment.EdgeOrganization)
	}
	if m.clearedcourse {
		edges = append(edges, enrollment.EdgeCourse)
	}
	if m.cleareduser {
		edges = append(edges, enrollment.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, enrollment.EdgeGroup)
	}
	if m.clearedprogress_entries {
		edges = append(edges, enrollment.EdgeProgressEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnrollmentMutation) EdgeCleared(name string) bool {
	switch name {
	case enrollment.EdgeOrganization:
		return m.clearedorganization
	case enrollment.EdgeCourse:
		return m.clearedcourse
	case enrollment.EdgeUser:
		return m.cleareduser
	case enrollment.EdgeGroup:
		return m.clearedgroup
	case enrollment.EdgeProgressEntries:
		return m.clearedprogress_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnrollmentMutation) ClearEdge(name string) error {
	switch name {
	case enrollment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case enrollment.EdgeCourse:
		m.ClearCourse()
		return nil
	case enrollment.EdgeUser:
		m.ClearUser()
		return nil
	case enrollment.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Enrollment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnrollmentMutation) ResetEdge(name string) error {
	switch name {
	case enrollment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case enrollment.EdgeCourse:
		m.ResetCourse()
		return nil
	case enrollment.EdgeUser:
		m.ResetUser()
		return nil
	case enrollment.EdgeGroup:
		m.ResetGroup()
		return nil
	case enrollment.EdgeProgressEntries:
		m.ResetProgressEntries()
		return nil
	}
	return fmt.Errorf("unknown Enrollment edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	capacity            *int
	addcapacity         *int
	metadata            *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	course              *uuid.UUID
	clearedcourse       bool
	enrollments         map[uuid.UUID]struct{}
	removedenrollments  map[uuid.UUID]struct{}
	clearedenrollments  bool
	done                bool
	oldValue            func(context.Context) (*Group, error)
	predicates          []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id uuid.UUID) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *GroupMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *GroupMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *GroupMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCourseID sets the "course_id" field.
func (m *GroupMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *GroupMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCourseID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *GroupMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[group.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *GroupMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[group.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *GroupMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, group.FieldCourseID)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetCapacity sets the "capacity" field.
func (m *GroupMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *GroupMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCapacity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *GroupMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *GroupMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *GroupMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[group.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *GroupMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[group.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *GroupMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, group.FieldCapacity)
}

// SetMetadata sets the "metadata" field.
func (m *GroupMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GroupMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GroupMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[group.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GroupMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[group.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GroupMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, group.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GroupMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[group.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GroupMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GroupMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *GroupMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[group.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *GroupMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *GroupMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddEnrollmentIDs adds the "enrollments" edge to the Enrollment entity by ids.
func (m *GroupMutation) AddEnrollmentIDs(ids ...uuid.UUID) {
	if m.enrollments == nil {
		m.enrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the Enrollment entity.
func (m *GroupMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the Enrollment entity was cleared.
func (m *GroupMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the Enrollment entity by IDs.
func (m *GroupMutation) RemoveEnrollmentIDs(ids ...uuid.UUID) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the Enrollment entity.
func (m *GroupMutation) RemovedEnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *GroupMutation) EnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *GroupMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.organization != nil {
		fields = append(fields, group.FieldOrganizationID)
	}
	if m.course != nil {
		fields = append(fields, group.FieldCourseID)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.capacity != nil {
		fields = append(fields, group.FieldCapacity)
	}
	if m.metadata != nil {
		fields = append(fields, group.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldOrganizationID:
		return m.OrganizationID()
	case group.FieldCourseID:
		return m.CourseID()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldCapacity:
		return m.Capacity()
	case group.FieldMetadata:
		return m.Metadata()
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case group.FieldCourseID:
		return m.OldCourseID(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldCapacity:
		return m.OldCapacity(ctx)
	case group.FieldMetadata:
		return m.OldMetadata(ctx)
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case group.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case group.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, group.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldCourseID) {
		fields = append(fields, group.FieldCourseID)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldCapacity) {
		fields = append(fields, group.FieldCapacity)
	}
	if m.FieldCleared(group.FieldMetadata) {
		fields = append(fields, group.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldCourseID:
		m.ClearCourseID()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldCapacity:
		m.ClearCapacity()
		return nil
	case group.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case group.FieldCourseID:
		m.ResetCourseID()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldCapacity:
		m.ResetCapacity()
		return nil
	case group.FieldMetadata:
		m.ResetMetadata()
		return nil
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, group.EdgeOrganization)
	}
	if m.course != nil {
		edges = append(edges, group.EdgeCourse)
	}
	if m.enrollments != nil {
		edges = append(edges, group.EdgeEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedenrollments != nil {
		edges = append(edges, group.EdgeEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, group.EdgeOrganization)
	}
	if m.clearedcourse {
		edges = append(edges, group.EdgeCourse)
	}
	if m.clearedenrollments {
		edges = append(edges, group.EdgeEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeOrganization:
		return m.clearedorganization
	case group.EdgeCourse:
		return m.clearedcourse
	case group.EdgeEnrollments:
		return m.clearedenrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case group.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case group.EdgeCourse:
		m.ResetCourse()
		return nil
	case group.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ModuleMutation represents an operation that mutates the Module nodes in the graph.
type ModuleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	title                   *string
	module_type             *string
	position                *int
	addposition             *int
	duration_seconds        *int
	addduration_seconds     *int
	status                  *string
	data                    *map[string]interface{}
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	course                  *uuid.UUID
	clearedcourse           bool
	content                 *uuid.UUID
	clearedcontent          bool
	progress_entries        map[uuid.UUID]struct{}
	removedprogress_entries map[uuid.UUID]struct{}
	clearedprogress_entries bool
	done                    bool
	oldValue                func(context.Context) (*Module, error)
	predicates              []predicate.Module
}

var _ ent.Mutation = (*ModuleMutation)(nil)

// moduleOption allows management of the mutation configuration using functional options.
type moduleOption func(*ModuleMutation)

// newModuleMutation creates new mutation for the Module entity.
func newModuleMutation(c config, op Op, opts ...moduleOption) *ModuleMutation {
	m := &ModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModuleID sets the ID field of the mutation.
func withModuleID(id uuid.UUID) moduleOption {
	return func(m *ModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Module
		)
		m.oldValue = func(ctx context.Context) (*Module, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Module.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModule sets the old Module of the mutation.
func withModule(node *Module) moduleOption {
	return func(m *ModuleMutation) {
		m.oldValue = func(context.Context) (*Module, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Module entities.
func (m *ModuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Module.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCourseID sets the "course_id" field.
func (m *ModuleMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *ModuleMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldCourseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *ModuleMutation) ResetCourseID() {
	m.course = nil
}

// SetContentID sets the "content_id" field.
func (m *ModuleMutation) SetContentID(u uuid.UUID) {
	m.content = &u
}

// ContentID returns the value of the "content_id" field in the mutation.
func (m *ModuleMutation) ContentID() (r uuid.UUID, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContentID returns the old "content_id" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldContentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentID: %w", err)
	}
	return oldValue.ContentID, nil
}

// ClearContentID clears the value of the "content_id" field.
func (m *ModuleMutation) ClearContentID() {
	m.content = nil
	m.clearedFields[module.FieldContentID] = struct{}{}
}

// ContentIDCleared returns if the "content_id" field was cleared in this mutation.
func (m *ModuleMutation) ContentIDCleared() bool {
	_, ok := m.clearedFields[module.FieldContentID]
	return ok
}

// ResetContentID resets all changes to the "content_id" field.
func (m *ModuleMutation) ResetContentID() {
	m.content = nil
	delete(m.clearedFields, module.FieldContentID)
}

// SetTitle sets the "title" field.
func (m *ModuleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ModuleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ModuleMutation) ResetTitle() {
	m.title = nil
}

// SetModuleType sets the "module_type" field.
func (m *ModuleMutation) SetModuleType(s string) {
	m.module_type = &s
}

// ModuleType returns the value of the "module_type" field in the mutation.
func (m *ModuleMutation) ModuleType() (r string, exists bool) {
	v := m.module_type
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleType returns the old "module_type" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldModuleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleType: %w", err)
	}
	return oldValue.ModuleType, nil
}

// ResetModuleType resets all changes to the "module_type" field.
func (m *ModuleMutation) ResetModuleType() {
	m.module_type = nil
}

// SetPosition sets the "position" field.
func (m *ModuleMutation) SetPosition(i int) {
	m.position = &i
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *ModuleMutation) Position() (r int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldPosition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// AddPosition adds i to the "position" field.
func (m *ModuleMutation) AddPosition(i int) {
	if m.addposition != nil {
		*m.addposition += i
	} else {
		m.addposition = &i
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *ModuleMutation) AddedPosition() (r int, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *ModuleMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// SetDurationSeconds sets the "duration_seconds" field.
func (m *ModuleMutation) SetDurationSeconds(i int) {
	m.duration_seconds = &i
	m.addduration_seconds = nil
}

// DurationSeconds returns the value of the "duration_seconds" field in the mutation.
func (m *ModuleMutation) DurationSeconds() (r int, exists bool) {
	v := m.duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSeconds returns the old "duration_seconds" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldDurationSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSeconds: %w", err)
	}
	return oldValue.DurationSeconds, nil
}

// AddDurationSeconds adds i to the "duration_seconds" field.
func (m *ModuleMutation) AddDurationSeconds(i int) {
	if m.addduration_seconds != nil {
		*m.addduration_seconds += i
	} else {
		m.addduration_seconds = &i
	}
}

// AddedDurationSeconds returns the value that was added to the "duration_seconds" field in this mutation.
func (m *ModuleMutation) AddedDurationSeconds() (r int, exists bool) {
	v := m.addduration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationSeconds clears the value of the "duration_seconds" field.
func (m *ModuleMutation) ClearDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	m.clearedFields[module.FieldDurationSeconds] = struct{}{}
}

// DurationSecondsCleared returns if the "duration_seconds" field was cleared in this mutation.
func (m *ModuleMutation) DurationSecondsCleared() bool {
	_, ok := m.clearedFields[module.FieldDurationSeconds]
	return ok
}

// ResetDurationSeconds resets all changes to the "duration_seconds" field.
func (m *ModuleMutation) ResetDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	delete(m.clearedFields, module.FieldDurationSeconds)
}

// SetStatus sets the "status" field.
func (m *ModuleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ModuleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ModuleMutation) ResetStatus() {
	m.status = nil
}

// SetData sets the "data" field.
func (m *ModuleMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *ModuleMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *ModuleMutation) ClearData() {
	m.data = nil
	m.clearedFields[module.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *ModuleMutation) DataCleared() bool {
	_, ok := m.clearedFields[module.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *ModuleMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, module.FieldData)
}

// SetCreatedAt sets the "created_at" field.
func (m *ModuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ModuleMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[module.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ModuleMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ModuleMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ModuleMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearContent clears the "content" edge to the Content entity.
func (m *ModuleMutation) ClearContent() {
	m.clearedcontent = true
	m.clearedFields[module.FieldContentID] = struct{}{}
}

// ContentCleared reports if the "content" edge to the Content entity was cleared.
func (m *ModuleMutation) ContentCleared() bool {
	return m.ContentIDCleared() || m.clearedcontent
}

// ContentIDs returns the "content" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentID instead. It exists only for internal usage by the builders.
func (m *ModuleMutation) ContentIDs() (ids []uuid.UUID) {
	if id := m.content; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *ModuleMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
}

// AddProgressEntryIDs adds the "progress_entries" edge to the ModuleProgress entity by ids.
func (m *ModuleMutation) AddProgressEntryIDs(ids ...uuid.UUID) {
	if m.progress_entries == nil {
		m.progress_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.progress_entries[ids[i]] = struct{}{}
	}
}

// ClearProgressEntries clears the "progress_entries" edge to the ModuleProgress entity.
func (m *ModuleMutation) ClearProgressEntries() {
	m.clearedprogress_entries = true
}

// ProgressEntriesCleared reports if the "progress_entries" edge to the ModuleProgress entity was cleared.
func (m *ModuleMutation) ProgressEntriesCleared() bool {
	return m.clearedprogress_entries
}

// RemoveProgressEntryIDs removes the "progress_entries" edge to the ModuleProgress entity by IDs.
func (m *ModuleMutation) RemoveProgressEntryIDs(ids ...uuid.UUID) {
	if m.removedprogress_entries == nil {
		m.removedprogress_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.progress_entries, ids[i])
		m.removedprogress_entries[ids[i]] = struct{}{}
	}
}

// RemovedProgressEntries returns the removed IDs of the "progress_entries" edge to the ModuleProgress entity.
func (m *ModuleMutation) RemovedProgressEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedprogress_entries {
		ids = append(ids, id)
	}
	return
}

// ProgressEntriesIDs returns the "progress_entries" edge IDs in the mutation.
func (m *ModuleMutation) ProgressEntriesIDs() (ids []uuid.UUID) {
	for id := range m.progress_entries {
		ids = append(ids, id)
	}
	return
}

// ResetProgressEntries resets all changes to the "progress_entries" edge.
func (m *ModuleMutation) ResetProgressEntries() {
	m.progress_entries = nil
	m.clearedprogress_entries = false
	m.removedprogress_entries = nil
}

// Where appends a list predicates to the ModuleMutation builder.
func (m *ModuleMutation) Where(ps ...predicate.Module) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Module, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Module).
func (m *ModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModuleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.course != nil {
		fields = append(fields, module.FieldCourseID)
	}
	if m.content != nil {
		fields = append(fields, module.FieldContentID)
	}
	if m.title != nil {
		fields = append(fields, module.FieldTitle)
	}
	if m.module_type != nil {
		fields = append(fields, module.FieldModuleType)
	}
	if m.position != nil {
		fields = append(fields, module.FieldPosition)
	}
	if m.duration_seconds != nil {
		fields = append(fields, module.FieldDurationSeconds)
	}
	if m.status != nil {
		fields = append(fields, module.FieldStatus)
	}
	if m.data != nil {
		fields = append(fields, module.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, module.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case module.FieldCourseID:
		return m.CourseID()
	case module.FieldContentID:
		return m.ContentID()
	case module.FieldTitle:
		return m.Title()
	case module.FieldModuleType:
		return m.ModuleType()
	case module.FieldPosition:
		return m.Position()
	case module.FieldDurationSeconds:
		return m.DurationSeconds()
	case module.FieldStatus:
		return m.Status()
	case module.FieldData:
		return m.Data()
	case module.FieldCreatedAt:
		return m.CreatedAt()
	case module.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case module.FieldCourseID:
		return m.OldCourseID(ctx)
	case module.FieldContentID:
		return m.OldContentID(ctx)
	case module.FieldTitle:
		return m.OldTitle(ctx)
	case module.FieldModuleType:
		return m.OldModuleType(ctx)
	case module.FieldPosition:
		return m.OldPosition(ctx)
	case module.FieldDurationSeconds:
		return m.OldDurationSeconds(ctx)
	case module.FieldStatus:
		return m.OldStatus(ctx)
	case module.FieldData:
		return m.OldData(ctx)
	case module.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case module.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Module field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case module.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case module.FieldContentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentID(v)
		return nil
	case module.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case module.FieldModuleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleType(v)
		return nil
	case module.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case module.FieldDurationSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSeconds(v)
		return nil
	case module.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case module.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case module.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case module.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModuleMutation) AddedFields() []string {
	var fields []string
	if m.addposition != nil {
		fields = append(fields, module.FieldPosition)
	}
	if m.addduration_seconds != nil {
		fields = append(fields, module.FieldDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case module.FieldPosition:
		return m.AddedPosition()
	case module.FieldDurationSeconds:
		return m.AddedDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case module.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	case module.FieldDurationSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown Module numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(module.FieldContentID) {
		fields = append(fields, module.FieldContentID)
	}
	if m.FieldCleared(module.FieldDurationSeconds) {
		fields = append(fields, module.FieldDurationSeconds)
	}
	if m.FieldCleared(module.FieldData) {
		fields = append(fields, module.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModuleMutation) ClearField(name string) error {
	switch name {
	case module.FieldContentID:
		m.ClearContentID()
		return nil
	case module.FieldDurationSeconds:
		m.ClearDurationSeconds()
		return nil
	case module.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Module nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModuleMutation) ResetField(name string) error {
	switch name {
	case module.FieldCourseID:
		m.ResetCourseID()
		return nil
	case module.FieldContentID:
		m.ResetContentID()
		return nil
	case module.FieldTitle:
		m.ResetTitle()
		return nil
	case module.FieldModuleType:
		m.ResetModuleType()
		return nil
	case module.FieldPosition:
		m.ResetPosition()
		return nil
	case module.FieldDurationSeconds:
		m.ResetDurationSeconds()
		return nil
	case module.FieldStatus:
		m.ResetStatus()
		return nil
	case module.FieldData:
		m.ResetData()
		return nil
	case module.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case module.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, module.EdgeCourse)
	}
	if m.content != nil {
		edges = append(edges, module.EdgeContent)
	}
	if m.progress_entries != nil {
		edges = append(edges, module.EdgeProgressEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case module.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case module.EdgeContent:
		if id := m.content; id != nil {
			return []ent.Value{*id}
		}
	case module.EdgeProgressEntries:
		ids := make([]ent.Value, 0, len(m.progress_entries))
		for id := range m.progress_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprogress_entries != nil {
		edges = append(edges, module.EdgeProgressEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case module.EdgeProgressEntries:
		ids := make([]ent.Value, 0, len(m.removedprogress_entries))
		for id := range m.removedprogress_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, module.EdgeCourse)
	}
	if m.clearedcontent {
		edges = append(edges, module.EdgeContent)
	}
	if m.clearedprogress_entries {
		edges = append(edges, module.EdgeProgressEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case module.EdgeCourse:
		return m.clearedcourse
	case module.EdgeContent:
		return m.clearedcontent
	case module.EdgeProgressEntries:
		return m.clearedprogress_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModuleMutation) ClearEdge(name string) error {
	switch name {
	case module.EdgeCourse:
		m.ClearCourse()
		return nil
	case module.EdgeContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Module unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModuleMutation) ResetEdge(name string) error {
	switch name {
	case module.EdgeCourse:
		m.ResetCourse()
		return nil
	case module.EdgeContent:
		m.ResetContent()
		return nil
	case module.EdgeProgressEntries:
		m.ResetProgressEntries()
		return nil
	}
	return fmt.Errorf("unknown Module edge %s", name)
}

// ModuleProgressMutation represents an operation that mutates the ModuleProgress nodes in the graph.
type ModuleProgressMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	status            *string
	score             *float32
	addscore          *float32
	attempts          *int
	addattempts       *int
	started_at        *time.Time
	completed_at      *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	enrollment        *uuid.UUID
	clearedenrollment bool
	module            *uuid.UUID
	clearedmodule     bool
	done              bool
	oldValue          func(context.Context) (*ModuleProgress, error)
	predicates        []predicate.ModuleProgress
}

var _ ent.Mutation = (*ModuleProgressMutation)(nil)

// moduleprogressOption allows management of the mutation configuration using functional options.
type moduleprogressOption func(*ModuleProgressMutation)

// newModuleProgressMutation creates new mutation for the ModuleProgress entity.
func newModuleProgressMutation(c config, op Op, opts ...moduleprogressOption) *ModuleProgressMutation {
	m := &ModuleProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeModuleProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModuleProgressID sets the ID field of the mutation.
func withModuleProgressID(id uuid.UUID) moduleprogressOption {
	return func(m *ModuleProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *ModuleProgress
		)
		m.oldValue = func(ctx context.Context) (*ModuleProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModuleProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModuleProgress sets the old ModuleProgress of the mutation.
func withModuleProgress(node *ModuleProgress) moduleprogressOption {
	return func(m *ModuleProgressMutation) {
		m.oldValue = func(context.Context) (*ModuleProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModuleProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModuleProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModuleProgress entities.
func (m *ModuleProgressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModuleProgressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModuleProgressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModuleProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnrollmentID sets the "enrollment_id" field.
func (m *ModuleProgressMutation) SetEnrollmentID(u uuid.UUID) {
	m.enrollment = &u
}

// EnrollmentID returns the value of the "enrollment_id" field in the mutation.
func (m *ModuleProgressMutation) EnrollmentID() (r uuid.UUID, exists bool) {
	v := m.enrollment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrollmentID returns the old "enrollment_id" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldEnrollmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrollmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrollmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrollmentID: %w", err)
	}
	return oldValue.EnrollmentID, nil
}

// ResetEnrollmentID resets all changes to the "enrollment_id" field.
func (m *ModuleProgressMutation) ResetEnrollmentID() {
	m.enrollment = nil
}

// SetModuleID sets the "module_id" field.
func (m *ModuleProgressMutation) SetModuleID(u uuid.UUID) {
	m.module = &u
}

// ModuleID returns the value of the "module_id" field in the mutation.
func (m *ModuleProgressMutation) ModuleID() (r uuid.UUID, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleID returns the old "module_id" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldModuleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleID: %w", err)
	}
	return oldValue.ModuleID, nil
}

// ResetModuleID resets all changes to the "module_id" field.
func (m *ModuleProgressMutation) ResetModuleID() {
	m.module = nil
}

// SetStatus sets the "status" field.
func (m *ModuleProgressMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ModuleProgressMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ModuleProgressMutation) ResetStatus() {
	m.status = nil
}

// SetScore sets the "score" field.
func (m *ModuleProgressMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ModuleProgressMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldScore(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ModuleProgressMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ModuleProgressMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ModuleProgressMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[moduleprogress.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ModuleProgressMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[moduleprogress.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ModuleProgressMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, moduleprogress.FieldScore)
}

// SetAttempts sets the "attempts" field.
func (m *ModuleProgressMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *ModuleProgressMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *ModuleProgressMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *ModuleProgressMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *ModuleProgressMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ModuleProgressMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ModuleProgressMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ModuleProgressMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[moduleprogress.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ModuleProgressMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[moduleprogress.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ModuleProgressMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, moduleprogress.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *ModuleProgressMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ModuleProgressMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ModuleProgressMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[moduleprogress.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ModuleProgressMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[moduleprogress.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ModuleProgressMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, moduleprogress.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ModuleProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModuleProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModuleProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModuleProgressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModuleProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ModuleProgress entity.
// If the ModuleProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModuleProgressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearEnrollment clears the "enrollment" edge to the Enrollment entity.
func (m *ModuleProgressMutation) ClearEnrollment() {
	m.clearedenrollment = true
	m.clearedFields[moduleprogress.FieldEnrollmentID] = struct{}{}
}

// EnrollmentCleared reports if the "enrollment" edge to the Enrollment entity was cleared.
func (m *ModuleProgressMutation) EnrollmentCleared() bool {
	return m.clearedenrollment
}

// EnrollmentIDs returns the "enrollment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnrollmentID instead. It exists only for internal usage by the builders.
func (m *ModuleProgressMutation) EnrollmentIDs() (ids []uuid.UUID) {
	if id := m.enrollment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnrollment resets all changes to the "enrollment" edge.
func (m *ModuleProgressMutation) ResetEnrollment() {
	m.enrollment = nil
	m.clearedenrollment = false
}

// ClearModule clears the "module" edge to the Module entity.
func (m *ModuleProgressMutation) ClearModule() {
	m.clearedmodule = true
	m.clearedFields[moduleprogress.FieldModuleID] = struct{}{}
}

// ModuleCleared reports if the "module" edge to the Module entity was cleared.
func (m *ModuleProgressMutation) ModuleCleared() bool {
	return m.clearedmodule
}

// ModuleIDs returns the "module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModuleID instead. It exists only for internal usage by the builders.
func (m *ModuleProgressMutation) ModuleIDs() (ids []uuid.UUID) {
	if id := m.module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModule resets all changes to the "module" edge.
func (m *ModuleProgressMutation) ResetModule() {
	m.module = nil
	m.clearedmodule = false
}

// Where appends a list predicates to the ModuleProgressMutation builder.
func (m *ModuleProgressMutation) Where(ps ...predicate.ModuleProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModuleProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModuleProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModuleProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModuleProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModuleProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModuleProgress).
func (m *ModuleProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModuleProgressMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.enrollment != nil {
		fields = append(fields, moduleprogress.FieldEnrollmentID)
	}
	if m.module != nil {
		fields = append(fields, moduleprogress.FieldModuleID)
	}
	if m.status != nil {
		fields = append(fields, moduleprogress.FieldStatus)
	}
	if m.score != nil {
		fields = append(fields, moduleprogress.FieldScore)
	}
	if m.attempts != nil {
		fields = append(fields, moduleprogress.FieldAttempts)
	}
	if m.started_at != nil {
		fields = append(fields, moduleprogress.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, moduleprogress.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, moduleprogress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, moduleprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModuleProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moduleprogress.FieldEnrollmentID:
		return m.EnrollmentID()
	case moduleprogress.FieldModuleID:
		return m.ModuleID()
	case moduleprogress.FieldStatus:
		return m.Status()
	case moduleprogress.FieldScore:
		return m.Score()
	case moduleprogress.FieldAttempts:
		return m.Attempts()
	case moduleprogress.FieldStartedAt:
		return m.StartedAt()
	case moduleprogress.FieldCompletedAt:
		return m.CompletedAt()
	case moduleprogress.FieldCreatedAt:
		return m.CreatedAt()
	case moduleprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModuleProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moduleprogress.FieldEnrollmentID:
		return m.OldEnrollmentID(ctx)
	case moduleprogress.FieldModuleID:
		return m.OldModuleID(ctx)
	case moduleprogress.FieldStatus:
		return m.OldStatus(ctx)
	case moduleprogress.FieldScore:
		return m.OldScore(ctx)
	case moduleprogress.FieldAttempts:
		return m.OldAttempts(ctx)
	case moduleprogress.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case moduleprogress.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case moduleprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case moduleprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ModuleProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moduleprogress.FieldEnrollmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrollmentID(v)
		return nil
	case moduleprogress.FieldModuleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleID(v)
		return nil
	case moduleprogress.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case moduleprogress.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case moduleprogress.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case moduleprogress.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case moduleprogress.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case moduleprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case moduleprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModuleProgressMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, moduleprogress.FieldScore)
	}
	if m.addattempts != nil {
		fields = append(fields, moduleprogress.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModuleProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case moduleprogress.FieldScore:
		return m.AddedScore()
	case moduleprogress.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case moduleprogress.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case moduleprogress.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModuleProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(moduleprogress.FieldScore) {
		fields = append(fields, moduleprogress.FieldScore)
	}
	if m.FieldCleared(moduleprogress.FieldStartedAt) {
		fields = append(fields, moduleprogress.FieldStartedAt)
	}
	if m.FieldCleared(moduleprogress.FieldCompletedAt) {
		fields = append(fields, moduleprogress.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModuleProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModuleProgressMutation) ClearField(name string) error {
	switch name {
	case moduleprogress.FieldScore:
		m.ClearScore()
		return nil
	case moduleprogress.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case moduleprogress.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModuleProgressMutation) ResetField(name string) error {
	switch name {
	case moduleprogress.FieldEnrollmentID:
		m.ResetEnrollmentID()
		return nil
	case moduleprogress.FieldModuleID:
		m.ResetModuleID()
		return nil
	case moduleprogress.FieldStatus:
		m.ResetStatus()
		return nil
	case moduleprogress.FieldScore:
		m.ResetScore()
		return nil
	case moduleprogress.FieldAttempts:
		m.ResetAttempts()
		return nil
	case moduleprogress.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case moduleprogress.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case moduleprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case moduleprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModuleProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enrollment != nil {
		edges = append(edges, moduleprogress.EdgeEnrollment)
	}
	if m.module != nil {
		edges = append(edges, moduleprogress.EdgeModule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModuleProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moduleprogress.EdgeEnrollment:
		if id := m.enrollment; id != nil {
			return []ent.Value{*id}
		}
	case moduleprogress.EdgeModule:
		if id := m.module; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModuleProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModuleProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModuleProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenrollment {
		edges = append(edges, moduleprogress.EdgeEnrollment)
	}
	if m.clearedmodule {
		edges = append(edges, moduleprogress.EdgeModule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModuleProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case moduleprogress.EdgeEnrollment:
		return m.clearedenrollment
	case moduleprogress.EdgeModule:
		return m.clearedmodule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModuleProgressMutation) ClearEdge(name string) error {
	switch name {
	case moduleprogress.EdgeEnrollment:
		m.ClearEnrollment()
		return nil
	case moduleprogress.EdgeModule:
		m.ClearModule()
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModuleProgressMutation) ResetEdge(name string) error {
	switch name {
	case moduleprogress.EdgeEnrollment:
		m.ResetEnrollment()
		return nil
	case moduleprogress.EdgeModule:
		m.ResetModule()
		return nil
	}
	return fmt.Errorf("unknown ModuleProgress edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	slug               *string
	status             *string
	settings           *map[string]interface{}
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	users              map[uuid.UUID]struct{}
	removedusers       map[uuid.UUID]struct{}
	clearedusers       bool
	contents           map[uuid.UUID]struct{}
	removedcontents    map[uuid.UUID]struct{}
	clearedcontents    bool
	courses            map[uuid.UUID]struct{}
	removedcourses     map[uuid.UUID]struct{}
	clearedcourses     bool
	groups             map[uuid.UUID]struct{}
	removedgroups      map[uuid.UUID]struct{}
	clearedgroups      bool
	enrollments        map[uuid.UUID]struct{}
	removedenrollments map[uuid.UUID]struct{}
	clearedenrollments bool
	done               bool
	oldValue           func(context.Context) (*Organization, error)
	predicates         []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
}

// SetSettings sets the "settings" field.
func (m *OrganizationMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *OrganizationMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *OrganizationMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[organization.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *OrganizationMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[organization.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *OrganizationMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, organization.FieldSettings)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddContentIDs adds the "contents" edge to the Content entity by ids.
func (m *OrganizationMutation) AddContentIDs(ids ...uuid.UUID) {
	if m.contents == nil {
		m.contents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contents[ids[i]] = struct{}{}
	}
}

// ClearContents clears the "contents" edge to the Content entity.
func (m *OrganizationMutation) ClearContents() {
	m.clearedcontents = true
}

// ContentsCleared reports if the "contents" edge to the Content entity was cleared.
func (m *OrganizationMutation) ContentsCleared() bool {
	return m.clearedcontents
}

// RemoveContentIDs removes the "contents" edge to the Content entity by IDs.
func (m *OrganizationMutation) RemoveContentIDs(ids ...uuid.UUID) {
	if m.removedcontents == nil {
		m.removedcontents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.contents, ids[i])
		m.removedcontents[ids[i]] = struct{}{}
	}
}

// RemovedContents returns the removed IDs of the "contents" edge to the Content entity.
func (m *OrganizationMutation) RemovedContentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontents {
		ids = append(ids, id)
	}
	return
}

// ContentsIDs returns the "contents" edge IDs in the mutation.
func (m *OrganizationMutation) ContentsIDs() (ids []uuid.UUID) {
	for id := range m.contents {
		ids = append(ids, id)
	}
	return
}

// ResetContents resets all changes to the "contents" edge.
func (m *OrganizationMutation) ResetContents() {
	m.contents = nil
	m.clearedcontents = false
	m.removedcontents = nil
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *OrganizationMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.courses == nil {
		m.courses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *OrganizationMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *OrganizationMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *OrganizationMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *OrganizationMutation) RemovedCoursesIDs() (ids []uuid.UUID) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *OrganizationMutation) CoursesIDs() (ids []uuid.UUID) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *OrganizationMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *OrganizationMutation) AddGroupIDs(ids ...uuid.UUID) {
	if m.groups == nil {
		m.groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *OrganizationMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *OrganizationMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *OrganizationMutation) RemoveGroupIDs(ids ...uuid.UUID) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *OrganizationMutation) RemovedGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *OrganizationMutation) GroupsIDs() (ids []uuid.UUID) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *OrganizationMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddEnrollmentIDs adds the "enrollments" edge to the Enrollment entity by ids.
func (m *OrganizationMutation) AddEnrollmentIDs(ids ...uuid.UUID) {
	if m.enrollments == nil {
		m.enrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the Enrollment entity.
func (m *OrganizationMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the Enrollment entity was cleared.
func (m *OrganizationMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the Enrollment entity by IDs.
func (m *OrganizationMutation) RemoveEnrollmentIDs(ids ...uuid.UUID) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the Enrollment entity.
func (m *OrganizationMutation) RemovedEnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *OrganizationMutation) EnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *OrganizationMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m.settings != nil {
		fields = append(fields, organization.FieldSettings)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldSettings:
		return m.Settings()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldSettings:
		return m.OldSettings(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldSettings) {
		fields = append(fields, organization.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldSettings:
		m.ResetSettings()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.contents != nil {
		edges = append(edges, organization.EdgeContents)
	}
	if m.courses != nil {
		edges = append(edges, organization.EdgeCourses)
	}
	if m.groups != nil {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.enrollments != nil {
		edges = append(edges, organization.EdgeEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeContents:
		ids := make([]ent.Value, 0, len(m.contents))
		for id := range m.contents {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedcontents != nil {
		edges = append(edges, organization.EdgeContents)
	}
	if m.removedcourses != nil {
		edges = append(edges, organization.EdgeCourses)
	}
	if m.removedgroups != nil {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.removedenrollments != nil {
		edges = append(edges, organization.EdgeEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeContents:
		ids := make([]ent.Value, 0, len(m.removedcontents))
		for id := range m.removedcontents {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedcontents {
		edges = append(edges, organization.EdgeContents)
	}
	if m.clearedcourses {
		edges = append(edges, organization.EdgeCourses)
	}
	if m.clearedgroups {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.clearedenrollments {
		edges = append(edges, organization.EdgeEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeContents:
		return m.clearedcontents
	case organization.EdgeCourses:
		return m.clearedcourses
	case organization.EdgeGroups:
		return m.clearedgroups
	case organization.EdgeEnrollments:
		return m.clearedenrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeContents:
		m.ResetContents()
		return nil
	case organization.EdgeCourses:
		m.ResetCourses()
		return nil
	case organization.EdgeGroups:
		m.ResetGroups()
		return nil
	case organization.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	email               *string
	password_hash       *string
	role                *string
	status              *string
	refresh_token_id    *string
	last_login_at       *time.Time
	metadata            *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	enrollments         map[uuid.UUID]struct{}
	removedenrollments  map[uuid.UUID]struct{}
	clearedenrollments  bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRefreshTokenID sets the "refresh_token_id" field.
func (m *UserMutation) SetRefreshTokenID(s string) {
	m.refresh_token_id = &s
}

// RefreshTokenID returns the value of the "refresh_token_id" field in the mutation.
func (m *UserMutation) RefreshTokenID() (r string, exists bool) {
	v := m.refresh_token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenID returns the old "refresh_token_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRefreshTokenID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenID: %w", err)
	}
	return oldValue.RefreshTokenID, nil
}

// ClearRefreshTokenID clears the value of the "refresh_token_id" field.
func (m *UserMutation) ClearRefreshTokenID() {
	m.refresh_token_id = nil
	m.clearedFields[user.FieldRefreshTokenID] = struct{}{}
}

// RefreshTokenIDCleared returns if the "refresh_token_id" field was cleared in this mutation.
func (m *UserMutation) RefreshTokenIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRefreshTokenID]
	return ok
}

// ResetRefreshTokenID resets all changes to the "refresh_token_id" field.
func (m *UserMutation) ResetRefreshTokenID() {
	m.refresh_token_id = nil
	delete(m.clearedFields, user.FieldRefreshTokenID)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddEnrollmentIDs adds the "enrollments" edge to the Enrollment entity by ids.
func (m *UserMutation) AddEnrollmentIDs(ids ...uuid.UUID) {
	if m.enrollments == nil {
		m.enrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the Enrollment entity.
func (m *UserMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the Enrollment entity was cleared.
func (m *UserMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the Enrollment entity by IDs.
func (m *UserMutation) RemoveEnrollmentIDs(ids ...uuid.UUID) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the Enrollment entity.
func (m *UserMutation) RemovedEnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *UserMutation) EnrollmentsIDs() (ids []uuid.UUID) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *UserMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.refresh_token_id != nil {
		fields = append(fields, user.FieldRefreshTokenID)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldOrganizationID:
		return m.OrganizationID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRefreshTokenID:
		return m.RefreshTokenID()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRefreshTokenID:
		return m.OldRefreshTokenID(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRefreshTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenID(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldRefreshTokenID) {
		fields = append(fields, user.FieldRefreshTokenID)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldRefreshTokenID:
		m.ClearRefreshTokenID()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRefreshTokenID:
		m.ResetRefreshTokenID()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.enrollments != nil {
		edges = append(edges, user.EdgeEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedenrollments != nil {
		edges = append(edges, user.EdgeEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.clearedenrollments {
		edges = append(edges, user.EdgeEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeEnrollments:
		return m.clearedenrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
